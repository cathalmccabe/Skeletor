`define T_ADDR_SIZE 32
`define ADDR_SIZE 32
#define N 2
#define GENERALDESCIPTION "This is a detailed explanation use several lines to explain everything. You will forget how smart you where when coding this module"
#define WORKER1 "G.Cabo"
#define GENRALREFERENCE "https://github.com/jaquerinte/MA_2019.git"

module a (TransAddrSize, AddrSize){
    #function "AND current addr_i with previous addr_i"
    #description GENERALDESCIPTION
    #coder  WORKER1
    #references GENRALREFERENCE

    in clk;
    in rts;
    in [AddrSize -1 : 0] addr;
    out [TransAddrSize-1: 0] taddr;
    out rdy;
$$
	reg [WORD_SIZE-1:0] main_mem [0:MEMORY_LINES-1];
	reg [LINE_SIZE-1:0] data_o_0;
	reg [LINE_SIZE-1:0] data_o_1;
	reg [LINE_SIZE-1:0] data_o_2;
	reg [LINE_SIZE-1:0] data_o_3; 
	reg [LINE_SIZE-1:0] data_o_4;    
    reg valid_0; 
    reg valid_1;
    reg valid_2;
    reg valid_3;
    reg valid_4;
    `ifdef SIM
    	initial begin
    		$readmemh("..\..\..\memory.hex", main_mem)
     `endif

	always @(posedge clk_i) begin
		// data_o_0 <= {WORD_SIZE{1'b0}};
		valid_0 <=0;                           
		if (!rstn_i) begin                                       
			// reset                                            
			integer i;         
			/* verilator lint_off BLKLOOPINIT*/                                 
			for(i=0;i<MEMORY_LINES; i=i+1) begin                 
				main_mem[i] <= {WORD_SIZE{1'b0}};                
			end   
			/* verilator lint_on BLKLOOPINIT*/                                             
			                                                    
		end                                                  
		else if (we_i) begin                                 
			main_mem[addr_i] <= data_i ;                         
			                                                    
		end else if (strobe_i) begin                        
			data_o_0[31:0] <= main_mem[addr_i>>2];                 
			data_o_0[63:32] <= main_mem[(addr_i>>2) + 1];
			data_o_0[95:64] <= main_mem[(addr_i>>2) + 2];                 
			data_o_0[127:96] <= main_mem[(addr_i>>2) + 3];
			valid_0 <= 1;                    
			                                                    
		end
		data_o <= data_o_4;
		valid_data_o <= valid_4;
		data_o_4 <=  data_o_3;
		valid_4 <= valid_3;
		data_o_3 <= data_o_2;
		valid_3 <= valid_2;
		data_o_2 <= data_o_1;
		valid_2 <= valid_1;
		data_o_1 <= data_o_0;
		valid_1 <= valid_0;

	end   
$$


}
module b (TransAddrSize, AddrSize){
    #function "OR current addr_i with previous addr_i"
    #description GENERALDESCIPTION
    #coder  WORKER1
    #references GENRALREFERENCE

    in rstn;                           
    in clk;                            
    in [AddrSize-1:0] addr;            
    in [TransAddrSize-1:0] taddr;            
    out [TransAddrSize-1:0] taddr;      
    out rdy;                            
}

module c(n){
    #function "rdy_o is high when a n bit counter overflow "
    #description GENERALDESCIPTION
    #coder  WORKER1
    #references GENRALREFERENCE

    in rts;
    in clk;
    out rdy;
}

module d(){
    #function  "Three way AND gate"
    #description GENERALDESCIPTION
    #coder  WORKER1
    #references GENRALREFERENCE

    in in1;
    in in2;
    in in3;
    out out1; // no puede ser out porque es una palabra reservada
}

module e(){
    #function  "Three way AND gate"
    #description GENERALDESCIPTION
    #coder  WORKER1
    #references GENRALREFERENCE

    in a;
    out b;
    $$
	adadad
	asdasda
	asdadsasdasd
    $$
}

module top simple_example(TransAddrSize = T_ADDR_SIZE, AddrSize = ADDR_SIZE){
    #function  "Module to provide a reference output"
    #coder  WORKER1
    #references GENRALREFERENCE

    in clk;
    in rts;
    in [AddrSize -1 : 0] addr;
    out [TransAddrSize-1: 0] taddr;
    out rdy;
    vwire base;
    

    a:x(AddrSize = AddrSize, TransAddrSize = TransAddrSize){
        in clk = in clk,
        in rts = in rts,
        in addr = in addr
    };

    b:y(TransAddrSize, AddrSize){
        in rstn = in rts,
        in clk = in clk,
        in addr = in addr,
        out taddr = out taddr
    };
    
    c:z(N){
        in rts = in rts,
        in clk = in clk
    };

    d:w(){
        out out1 = out rdy
    };

    e:test(){
        in a = base
    };
    
    wire [TransAddrSize-1:0] x.taddr -> y.taddr;
    wire x.rdy -> w.in1;
    wire y.rdy -> w.in2;
    wire z.rdy -> w.in3;
    
}
